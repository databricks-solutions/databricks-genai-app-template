# Deployment Guide - Host App Integration

This guide explains how to integrate the Agent Monitoring App into a host React application (specifically for `dbdemos-genai` integration).

## Overview

The Agent Monitoring App can be deployed as a compiled, standalone application within a host React app. The key feature is **runtime configuration** - the app reads its endpoint configuration from an `app_config.json` file at runtime, allowing the host app to dynamically configure available endpoints without rebuilding.

## Architecture

```
┌─────────────────────────────────────────┐
│        Host App (dbdemos-genai)         │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │   Agent Monitoring App (built)    │ │
│  │                                   │ │
│  │   Reads config at runtime ────────┼─┼──> app_config.json
│  │   from public/app_config.json     │ │    (generated by host)
│  └───────────────────────────────────┘ │
│                                         │
│  Backend generates endpoints config     │
│  based on user's available resources    │
└─────────────────────────────────────────┘
```

## Quick Start

### 1. Build for Deployment

Run the deployment preparation script:

```bash
./scripts/prepare_for_host.sh [output_directory]
```

This will:
- Build the React frontend with optimized settings
- Copy all build artifacts to the output directory
- Create a template `app_config.json.template`
- Generate detailed integration instructions

**Example:**
```bash
# Build and output to default location (./dist/agent-monitoring-app)
./scripts/prepare_for_host.sh

# Or specify a custom output directory
./scripts/prepare_for_host.sh /path/to/host-app/public/agent-monitoring
```

### 2. Configure Endpoints

Create `app_config.json` in the same directory as `index.html`:

```json
{
  "endpoints": [
    {
      "displayName": "My Databricks Agent",
      "endpointName": "ka-6a76cd22-endpoint",
      "type": "databricks-agent"
    },
    {
      "displayName": "Claude Sonnet 4",
      "endpointName": "databricks-claude-sonnet-4",
      "type": "openai-chat"
    }
  ],
  "apiBaseUrl": "/api"
}
```

### 3. Integrate into Host App

Copy the built app to your host application's public directory or serve it as a static route.

## Configuration Reference

### `app_config.json` Schema

```typescript
interface AppConfig {
  endpoints: Array<{
    displayName: string;           // User-friendly name shown in UI
    endpointName: string;          // Databricks endpoint identifier
    type: "openai-chat" | "databricks-agent";  // Endpoint type
  }>;
  apiBaseUrl?: string;             // Optional: Base URL for API calls
}
```

### Endpoint Types

#### `databricks-agent`
For Databricks Agent endpoints that expect the following request format:
```json
{
  "input": [
    {"role": "user", "content": "Your question"}
  ]
}
```

#### `openai-chat`
For OpenAI-compatible endpoints that use standard chat completions format:
```json
{
  "messages": [
    {"role": "user", "content": "Your question"}
  ],
  "max_tokens": 1000,
  "temperature": 0.1
}
```

## Integration Patterns

### Pattern 1: Static Configuration

The simplest approach - create `app_config.json` manually and commit it with your deployment.

**Pros:**
- Simple to implement
- Easy to understand and debug

**Cons:**
- Configuration is static
- Requires rebuild/redeploy to change endpoints

**Use when:**
- Endpoints rarely change
- All users should see the same endpoints

### Pattern 2: Dynamic Configuration (Recommended for dbdemos-genai)

Generate `app_config.json` dynamically based on available resources.

**Pros:**
- Flexible and adaptable
- Can customize per user/deployment
- No rebuild needed to add/remove endpoints

**Cons:**
- Requires backend logic to generate config

**Use when:**
- Endpoints vary by environment
- Endpoints depend on user permissions or resources
- You want to discover available endpoints automatically

#### Implementation Example

**Backend (Python/FastAPI):**
```python
from fastapi import FastAPI
from fastapi.responses import JSONResponse
from databricks.sdk import WorkspaceClient

app = FastAPI()

@app.get("/agent-monitoring/app_config.json")
async def generate_app_config():
    """Dynamically generate configuration based on available endpoints."""
    
    # Get Databricks workspace client
    w = WorkspaceClient()
    
    # List available serving endpoints
    serving_endpoints = w.serving_endpoints.list()
    
    # Convert to app config format
    endpoints = []
    for ep in serving_endpoints:
        # Determine endpoint type based on configuration
        endpoint_type = "databricks-agent" if "agent" in ep.name.lower() else "openai-chat"
        
        endpoints.append({
            "displayName": ep.name,
            "endpointName": ep.name,
            "type": endpoint_type
        })
    
    return JSONResponse({
        "endpoints": endpoints,
        "apiBaseUrl": "/api"
    })
```

**Frontend (Host App):**
The Agent Monitoring App will automatically fetch `/app_config.json` on load.

### Pattern 3: Environment-Based Configuration

Generate different configs for dev/staging/prod environments.

**Build-time generation:**
```bash
# Generate config for production
./scripts/generate_prod_config.sh > dist/agent-monitoring-app/app_config.json

# Or for development
./scripts/generate_dev_config.sh > dist/agent-monitoring-app/app_config.json
```

## Backend API Requirements

The Agent Monitoring App requires the following API endpoints from the host:

### 1. Invoke Endpoint
```
POST /api/invoke_endpoint

Request:
{
  "endpoint_name": "my-endpoint",
  "messages": [{"role": "user", "content": "Hi"}],
  "endpoint_type": "databricks-agent"
}

Response:
{
  "choices": [{
    "message": {
      "role": "assistant",
      "content": "Response text",
      "structured_data": {  // Optional: for chart rendering
        "headers": ["Column1", "Column2"],
        "rows": [["Value1", "Value2"]],
        "chart_config": {"type": "bar", "x_column": 0, "y_column": 1}
      }
    }
  }]
}
```

### 2. Get Tracing Experiment
```
GET /api/tracing_experiment

Response:
{
  "experiment_id": "1234567890",
  "link": "https://your-workspace.cloud.databricks.com/#mlflow/experiments/1234567890"
}
```

### 3. Log Feedback (Optional)
```
POST /api/log_feedback

Request:
{
  "trace_id": "abc-123",
  "assessment_name": "good_response0",
  "assessment_value": true
}
```

## Local Development vs. Deployment

### Local Development
When running locally with `./watch.sh`, the app uses:
- Default hardcoded endpoints (from `client/src/config.ts`)
- Relative API calls to `http://localhost:8000/api`
- Hot module reloading for rapid development

### Deployment
When deployed in a host app, the app uses:
- Runtime configuration from `app_config.json`
- API calls to `apiBaseUrl` (or relative if not specified)
- Optimized production build with code splitting

## Testing the Integration

### 1. Local Testing

Build and test locally:
```bash
# Build the app
./scripts/prepare_for_host.sh ./test-deployment

# Create test config
cd ./test-deployment
cp app_config.json.template app_config.json
# Edit app_config.json with your test endpoints

# Serve with a simple HTTP server
python3 -m http.server 8080

# Open browser to http://localhost:8080
```

### 2. Integration Testing

Test within your host app:
```bash
# Copy to host app
cp -r ./dist/agent-monitoring-app/* /path/to/host-app/public/agent-monitoring/

# Start host app
cd /path/to/host-app
npm run dev

# Navigate to your integrated route
open http://localhost:3000/agent-monitoring
```

## Troubleshooting

### Issue: Endpoints not appearing in dropdown

**Symptoms:** Dropdown shows only "Databricks Agent", no dynamic endpoints

**Causes:**
1. `app_config.json` not found or not in correct location
2. `app_config.json` has invalid JSON syntax
3. CORS issues preventing fetch

**Solutions:**
- Check browser console for errors
- Verify `app_config.json` is in same directory as `index.html`
- Verify JSON is valid: `cat app_config.json | jq`
- Check network tab to see if `/app_config.json` request succeeds

### Issue: API calls failing (404 or CORS errors)

**Symptoms:** Messages not sending, errors in console

**Causes:**
1. Backend API not running
2. `apiBaseUrl` incorrect in `app_config.json`
3. CORS not configured on backend

**Solutions:**
- Verify backend is running: `curl http://localhost:8000/api/health`
- Check `apiBaseUrl` matches your backend URL
- Add CORS middleware to backend:
  ```python
  from fastapi.middleware.cors import CORSMiddleware
  
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],  # Or specific origins
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )
  ```

### Issue: Charts not rendering

**Symptoms:** Text appears but charts don't show

**Causes:**
1. Agent response doesn't include a markdown table
2. `recharts` library not loaded correctly
3. `structured_data` not being extracted

**Solutions:**
- Check browser console for rendering errors
- Verify agent response includes a properly formatted markdown table
- Check network response for `structured_data` field
- Verify `recharts` is in the bundle: check `build/assets/ui-vendor-*.js`

### Issue: Styles not loading correctly

**Symptoms:** App appears unstyled or broken

**Causes:**
1. Base path mismatch
2. Assets not served correctly
3. CSS not loaded

**Solutions:**
- Check browser console for 404 errors on CSS files
- Verify all assets in `build/assets/` are accessible
- Check `base` setting in `vite.config.ts` matches your deployment path
- If serving from subdirectory, update `base: './'` to `base: '/your-subpath/'`

## Advanced Topics

### Custom Styling

To customize the app's appearance to match your host app:

1. **Option 1: CSS Override**
   Add custom CSS after loading the app:
   ```html
   <link rel="stylesheet" href="/agent-monitoring/assets/index.css">
   <link rel="stylesheet" href="/custom-overrides.css">
   ```

2. **Option 2: Theme Customization**
   The app uses CSS variables for theming. Override in your host app:
   ```css
   :root {
     --primary: your-primary-color;
     --background: your-background-color;
     /* ... other variables */
   }
   ```

### Security Considerations

1. **API Authentication:** Ensure the backend API validates user permissions before invoking endpoints
2. **CORS:** Configure CORS appropriately - don't use `allow_origins=["*"]` in production
3. **Content Security Policy:** Update CSP headers to allow loading assets
4. **Sensitive Data:** Don't expose sensitive endpoint details in `app_config.json` if it's publicly accessible

### Performance Optimization

The build is already optimized with:
- Code splitting (React, UI vendors separate)
- Tree shaking
- Minification
- Gzip-friendly output

For further optimization:
- Enable HTTP/2 on your server
- Use CDN for static assets
- Implement service worker for offline support
- Enable brotli compression

## Support and Contribution

For issues, questions, or contributions:
- Check the main `README.md` for project overview
- Review `CLAUDE.md` for development context
- Open issues on the repository
- Refer to inline code comments for implementation details

## Appendix: File Structure

After running `prepare_for_host.sh`, your output directory will contain:

```
dist/agent-monitoring-app/
├── index.html                      # Main HTML entry point
├── assets/
│   ├── index-[hash].js            # Main app bundle
│   ├── index-[hash].css           # Styles
│   ├── react-vendor-[hash].js     # React libraries
│   └── ui-vendor-[hash].js        # UI libraries (recharts, lucide)
├── app_config.json.template        # Configuration template
├── INTEGRATION_GUIDE.md            # Quick integration reference
└── [other static assets]           # Images, fonts, etc.
```

Deploy all files together to ensure proper loading.

